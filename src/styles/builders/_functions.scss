//
//////////////////////////////////////////
//  Functions
//////////////////////////////////////////
//
// - Strings
// - Maps
// - Uses

//
// --------------------------------------
//  Strings
// --------------------------------------
//

//
//  contain: Return whether `$value` is contained in `$list`
//
//  Required arguments:
//    @param [list] $list
//    @param [$value] $value
//
//  @return Bool
//

@function contain($list, $value) {
  @return not not index($list, $value);
}

@function capitalize($string) {
  @return to-upper-case(str-slice($string, 1, 1)) + str-slice($string, 2);
}

@function uncapitalize($string) {
  @return to-lower-case(str-slice($string, 1, 1)) + str-slice($string, 2);
}

@function camelize($string) {
  $progress: $string;
  $result: "";
  $exclude: " ", "-", "–", "—", "_", ",", ";", ":", ".";
  @while str-length($progress) > 0 {
    $char: str-slice($progress, 1, 1);
    @if contain($exclude, $char) {
      $progress: capitalize(str-slice($progress, 2, 2)) + str-slice($progress, 3);
    } @else {
      $result: $result + $char;
      $progress: str-slice($progress, 2);
    }
  }
  @return $result;
}

//
// --------------------------------------
//  Maps
// --------------------------------------
//

//
//  str-explode: Split a string by delimiter
//
//  Required arguments:
//    `$string` String
//    `$delimiter` String *predefined*
//
//  Example of use:
//    str-explode('some-things-will-never-change', '-')
//
//  @return List
//

@function str-explode($string, $delimiter: "") {
  @if type-of($string) != "string" {
    @error 'The argument $string: `#{$string}` is of incorrect type: `#{type-of($string)}`. Type of `String` is required!';
  } @else if type-of($delimiter) != "string" {
    @error 'The argument $string: `#{$string}` is of incorrect type: `#{type-of($delimiter)}`. Type of `String` is required!';
  }
  $result: ();
  $running: true;
  @if str-length($delimiter) == 0 {
    @for $i from 1 through str-length($string) {
      $result: append($result, str-slice($string, $i, $i));
    }
    @return $result;
  }
  @while $running {
    $index: str-index($string, $delimiter);
    @if $index != null {
      $item: str-slice($string, 1, ($index - 1));
      $result: append($result, $item);
      $string: str-slice($string, ($index + str-length($delimiter)));
    } @else {
      $running: false;
    }
  }
  @return append($result, $string);
}

//
//  deep-map-check: Check if nested map has a value by the keys
//
//  Required arguments:
//    `$map` Map
//    `$keys` String(s)
//
//  Example of use:
//    deep-map-check($nested-map, 'key-1', 'key-2')
//
//  @return Bool
//

@function deep-map-check($map, $keys...) {
  @if type-of($map) != "map" {
    @error 'The argument $map: `#{$map}` is of incorrect type: `#{type-of($map)}`. Type of `Map` is required!';
  }
  @each $key in $keys {
    @if not map-has-key($map, $key) {
      @return false;
    }
    $map: map-get($map, $key);
  }
  @return true;
}

//
//  deep-map-get: Get a value from nested map by the keys
//
//  Required arguments:
//    `$map` Map
//    `$keys` String(s)
//
//  Example of use:
//    deep-map-get($dfr-spacing, 'xs', 'y')
//
//  @return Unspecified (it may return anything as a result)
//

@function deep-map-get($map, $keys...) {
  @if type-of($map) != "map" {
    @error 'The argument $map: `#{$map}` is of incorrect type: `#{type-of($map)}`. Type of `Map` is required!';
  }
  @each $key in $keys {
    $map: map-get($map, $key);
  }
  @return $map;
}

//
//  get: search for any value contained within nested maps, by using dot notation as the key argument
//
//  Required arguments:
//    `$key` String
//
//  Example of use:
//    get('border.radius.xs')
//
//  Dependencies:
//    deep-map-check, deep-map-get, str-explode
//
//  @return Anything
//

@function get($key, $map) {
  $keys: str-explode($key, ".");

  @if not deep-map-check($map, $keys...) {
    @error 'The argument $map: `#{$map}` doesn\'t has some of the $keys: `#{$keys}`!';
  }

  @return deep-map-get($map, $keys...);
}

//
//  deep-map-has-key: map-has-key function for nested maps
//
//  Required arguments:
//    `$submap` String
//    `$map` Map
//
//  Example of use:
//    deep-map-has-key('primary.light', $colors)
//
//  @return Anything
//

@function deep-map-has-key($submap, $map) {
  $themap: get($submap, $map);
  @return $themap;
}

//
// map-extend: jQuery-style extend function for when `map-merge()` isn't enough. Use when we need to merge more than two maps and/or need a merge to be recursive.
//
// @param $map
//   @type first map
// @param $maps
//   @type list of maps
// @param $deep
//   @type boolean
//   @default false
//   @desc Whether or not to enable recursive mode.
//
// @return merged map
//

@function map-extend($map, $maps... /*, $deep */) {
  $last: nth($maps, -1);
  $deep: $last == true;
  $max: if($deep, length($maps) - 1, length($maps));
  @for $i from 1 through $max {
    $current: nth($maps, $i);
    @if not $deep {
      $map: map-merge($map, $current);
    } @else {
      @each $key, $value in $current {
        @if type-of($value) == "map" and type-of(map-get($map, $key)) == "map" {
          $value: map-extend(map-get($map, $key), $value, true);
        }
        $map: map-merge(
          $map,
          (
            $key: $value,
          )
        );
      }
    }
  }
  @return $map;
}

//
// --------------------------------------
//  Uses
// --------------------------------------
//

@function use-space($key) {
  @if map-has-key($spaces, $key) {
    $key: map-get($spaces, $key);
    @return $key;
  } @else {
    @error '#{$key} key does not exist in $spaces map';
  }
}

@function use-color($key) {
  @if map-has-key($colors, $key) {
    $key: map-get($colors, $key);
    @return $key;
  } @else {
    @error '#{$key} key does not exist in $colors map';
  }
}

@function use-layer($key) {
  @if map-has-key($layers, $key) {
    $key: map-get($layers, $key);
    @return $key;
  } @else {
    @error '#{$key} key does not exist in $layers map';
  }
}
