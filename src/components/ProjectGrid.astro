---
import styles from "./ProjectGrid.module.scss";
import { Image } from "astro:assets";

type ProjectMeta = {
  slug: string;
  title: string;
  skills: string[];
  // Para compatibilidad: si no hay poster/video, usar thumbnail
  thumbnail?: string;
  // Nuevos campos: definidos en cada página de proyecto
  poster?: any; // ImageMetadata de astro:assets
  video?: string; // URL del .webm
  videoMp4?: string;
  videoMobile?: string;
  order?: number; // opcional: prioridad de orden (menor número = primero)
  showInHome?: boolean; // opcional: si es false, no aparece en la grid de Home
};

const modules = await Astro.glob("../pages/projects/*.astro");
const projects = modules
  .map((m) => (m as unknown as { project?: ProjectMeta }).project)
  .filter((p): p is ProjectMeta => Boolean(p))
  // Solo mostrar los que no declaran showInHome false (por defecto: visible)
  .filter((p) => p.showInHome !== false)
  .sort((a, b) => (a.order ?? Number.MAX_SAFE_INTEGER) - (b.order ?? Number.MAX_SAFE_INTEGER));

const count = projects.length;
---

<section class={styles.section} aria-labelledby="selected-work">
  <header class={styles.header}>
    <h2 id="selected-work" class={styles.title}>Selected Work</h2>
    <div class={styles.count}>({count})</div>
  </header>

  <div class={styles.grid}>
    {
      projects.map((p) => (
        <a href={`/projects/${p.slug}`} class={styles.card} rel="nofollow" data-card>
          <div class={styles.thumb} data-nosnippet>
            {p.poster ? (
              <Image
                class={styles.thumbImg}
                src={p.poster}
                alt=""
                aria-hidden="true"
                loading="lazy"
              />
            ) : (
              <img class={styles.thumbImg} src={p.thumbnail} alt="" aria-hidden="true" />
            )}
            {p.video && (
              <video
                class={styles.thumbVideo}
                src={p.video}
                muted
                loop
                playsinline
                preload="metadata"
                poster={p.poster?.src}
                tabindex="-1"
                aria-hidden="true"
                data-thumb-video
              >
                <source src={p.video} type="video/webm" />
                <source src={p.videoMp4} type="video/mp4" media="(min-width: 768px)" />
                <source src={p.videoMobile} type="video/mp4" media="(max-width: 767px)" />
              </video>
            )}
          </div>
          <div class={styles.info}>
            <div class={styles.cardTitle} data-nosnippet>
              <span data-nosnippet>{p.title}</span>
            </div>
            <div class={styles.skills} data-nosnippet>
              {p.skills.join(", ")}
            </div>
          </div>
        </a>
      ))
    }
  </div>

  <script is:inline type="module">
    const cards = Array.from(document.querySelectorAll("[data-card]"));

    // Solo activar en punteros finos (ratón)
    const finePointer = matchMedia("(pointer: fine)");
    if (finePointer.matches) {
      cards.forEach((card) => {
        const video = card.querySelector("[data-thumb-video]");

        const onMove = (e) => {
          const rect = card.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          card.style.setProperty("--x", x + "px");
          card.style.setProperty("--y", y + "px");
        };

        if (video) {
          const markPainted = () => card.setAttribute("data-painted", "1");

          // Precarga y "prepaint" de un frame real antes del hover
          const preheat = () => {
            if (video.dataset.preheated) return;
            video.preload = "auto";
            try {
              const p = video.play();
              if (p && typeof p.then === "function") p.catch(() => {});
            } catch {}
            video.dataset.preheated = "1";

            if ("requestVideoFrameCallback" in video) {
              const rvfc = video.requestVideoFrameCallback.bind(video);
              rvfc(() => {
                markPainted();
                try {
                  video.pause();
                } catch {}
              });
            } else {
              const onSeeked = () => {
                video.removeEventListener("seeked", onSeeked);
                markPainted();
                try {
                  video.pause();
                } catch {}
              };
              try {
                if (video.readyState < 1) {
                  const onLoadedMetadata = () => {
                    video.removeEventListener("loadedmetadata", onLoadedMetadata);
                    try {
                      video.currentTime = 0.05;
                    } catch {}
                  };
                  video.addEventListener("loadedmetadata", onLoadedMetadata, { once: true });
                  video.load();
                } else {
                  video.currentTime = Math.min(0.05, (video.duration || 0.06) - 0.01);
                }
              } catch {}
              video.addEventListener("seeked", onSeeked, { once: true });
            }
          };

          // Precalentar cuando se aproxima al viewport
          if ("IntersectionObserver" in window) {
            const io = new IntersectionObserver(
              (entries) => {
                entries.forEach((e) => {
                  if (e.isIntersecting) {
                    preheat();
                    io.unobserve(card);
                  }
                });
              },
              { rootMargin: "200px" }
            );
            io.observe(card);
          } else {
            preheat();
          }
        }

        const playSafe = () => {
          if (!video || typeof video.play !== "function") return;
          try {
            const p = video.play();
            if (p && typeof p.then === "function") p.catch(() => {});
          } catch {}
        };

        // Fase 1: hacer visible el vídeo, Fase 2: ocultar el poster y reproducir
        const startFadeIn = () => {
          if (!video) return;
          const onOpaque = (ev) => {
            if (ev.target !== video || ev.propertyName !== "opacity") return;
            video.removeEventListener("transitionend", onOpaque);
            // Fase 2: ocultar poster y empezar reproducción
            card.setAttribute("data-hover", "1");
            playSafe();
          };
          // Escuchar el final de la transición de opacidad del vídeo
          video.addEventListener("transitionend", onOpaque);
          // Fase 1: mostrar el vídeo (mantener poster visible mientras)
          card.setAttribute("data-video-in", "1");
        };

        const onEnter = () => {
          if (!video) return;
          // Si ya hay un frame pintado, podemos iniciar el fade-in
          if (card.hasAttribute("data-painted")) {
            startFadeIn();
          } else {
            // Precalentar inmediatamente y arrancar fade-in en cuanto se pinte
            try {
              const p = video.play();
              if (p && typeof p.then === "function") p.catch(() => {});
            } catch {}
            if ("requestVideoFrameCallback" in video) {
              const rvfc = video.requestVideoFrameCallback.bind(video);
              const once = () => {
                card.setAttribute("data-painted", "1");
                try {
                  video.pause();
                } catch {}
                startFadeIn();
              };
              rvfc(() => once());
            } else {
              const onCanPlay = () => {
                video.removeEventListener("canplay", onCanPlay);
                card.setAttribute("data-painted", "1");
                try {
                  video.pause();
                } catch {}
                startFadeIn();
              };
              video.addEventListener("canplay", onCanPlay, { once: true });
            }
          }
        };

        const onLeave = () => {
          card.removeAttribute("data-hover");
          card.removeAttribute("data-video-in");
          if (video && typeof video.pause === "function") {
            try {
              video.pause();
              // Dejar el vídeo en > 0 para evitar frame negro en siguiente hover
              video.currentTime = Math.min(0.05, (video.duration || 0.06) - 0.01);
            } catch {}
          }
          // Opcional: limpiar variables si sales de la card
          // card.style.removeProperty("--x");
          // card.style.removeProperty("--y");
        };

        card.addEventListener("mouseenter", onEnter);
        card.addEventListener("mousemove", onMove);
        card.addEventListener("mouseleave", onLeave);
        // Accesibilidad: soporte foco/blur con teclado en desktop
        card.addEventListener("focus", onEnter);
        card.addEventListener("blur", onLeave);
      });
    }
  </script>
</section>
